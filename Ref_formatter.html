<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reference Formatter Pro</title>
    
    <!-- Favicon: White Quotes on Dark Background (Matches Header Logo) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='25' fill='%231D1D1F'/><text x='50' y='75' font-size='80' font-family='Georgia, serif' font-weight='bold' text-anchor='middle' fill='white'>‚Äù</text></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=SF+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
                        mono: ['SF Mono', 'Menlo', 'Monaco', 'Courier New', 'monospace'],
                    },
                    colors: {
                        ios: {
                            bg: '#F5F5F7',
                            card: '#FFFFFF',
                            blue: '#007AFF',
                            text: '#1D1D1F',
                            gray: '#8E8E93',
                            border: '#E5E5EA',
                            green: '#34C759',
                            orange: '#FF9500',
                            red: '#FF3B30'
                        }
                    },
                    boxShadow: {
                        'soft': '0 8px 30px rgba(0,0,0,0.04)',
                        'inner-light': 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.01)',
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #F5F5F7;
            color: #1D1D1F;
            -webkit-font-smoothing: antialiased;
        }

        .ios-card {
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.03);
            border: 1px solid rgba(0,0,0,0.02);
            transition: all 0.2s ease;
        }

        .ios-input {
            background-color: #F2F2F7;
            border: 1px solid transparent;
            color: #1D1D1F;
            transition: all 0.2s;
        }
        .ios-input:focus {
            background-color: #FFFFFF;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
            outline: none;
        }

        .style-btn {
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .style-btn.active {
            background-color: #007AFF;
            color: white;
            border-color: #007AFF;
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.2);
        }

        /* HTML Preview Styling */
        .citation-preview em { font-style: italic; color: #1D1D1F; }
        .citation-preview strong { font-weight: 700; color: #1D1D1F; }
        
        /* Loading Animation */
        .spinner {
            border: 2px solid rgba(0, 0, 0, 0.1);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border-left-color: #007AFF;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #D1D1D6; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #8E8E93; }
        
        /* Error Shake Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }
        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden font-sans">

    <!-- Header -->
    <header class="bg-white border-b border-ios-border h-16 flex items-center justify-between px-6 shrink-0 z-10">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-black rounded-lg flex items-center justify-center text-white">
                <i class="ph ph-quotes text-xl"></i>
            </div>
            <h1 class="text-xl font-bold tracking-tight text-[#1D1D1F]">Reference Formatter <span class="text-ios-blue font-medium text-sm ml-1"></span></h1>
        </div>
        <div>
            <span class="px-3 py-1 rounded-full bg-[#F2F2F7] text-[#8E8E93] text-xs font-semibold tracking-wide uppercase flex items-center gap-2">
                <i class="ph ph-magnifying-glass text-ios-blue"></i>
                Title Search & Abbr.
            </span>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        
        <!-- Left: Input Area -->
        <div class="w-1/2 flex flex-col border-r border-ios-border bg-[#FAFAFA]">
            <div class="p-4 border-b border-ios-border flex justify-between items-center bg-white/50 backdrop-blur-sm">
                <h2 class="text-sm font-semibold text-[#8E8E93] uppercase tracking-wide flex items-center gap-2">
                    <i class="ph ph-code"></i> Input
                </h2>
                <div class="flex gap-2">
                    <button onclick="clearInput()" class="text-xs text-[#8E8E93] hover:text-[#FF3B30] transition-colors font-medium px-2 py-1">
                        Clear
                    </button>
                    <button onclick="processInput()" id="fetchBtn" class="bg-[#1D1D1F] hover:bg-[#333] text-white px-3 py-1 rounded-md text-xs font-semibold transition-colors flex items-center gap-2 shadow-sm">
                        <span>Fetch / Search</span>
                        <i class="ph ph-arrow-right"></i>
                    </button>
                </div>
            </div>
            <div class="flex-1 relative group flex flex-col">
                <textarea id="bibInput" class="w-full flex-1 p-6 bg-transparent resize-none focus:outline-none font-mono text-sm leading-relaxed text-[#1D1D1F]" 
                    placeholder="Paste BibTeX, DOI (10.1038/...), or Paper Title here...&#10;&#10;Examples:&#10;10.1038/s41563-024-01800-w&#10;Electric field effect in atomically thin carbon films&#10;@article{...}"
                    spellcheck="false"></textarea>
                
                <!-- Error Message Area -->
                <div id="inputError" class="hidden mx-6 mb-6 p-3 bg-red-50 border border-red-100 rounded-lg flex items-start gap-2">
                    <i class="ph ph-warning-circle text-red-500 mt-0.5"></i>
                    <div class="flex-1">
                        <p class="text-xs font-semibold text-red-600 mb-0.5">Direct URL not supported</p>
                        <p class="text-xs text-red-500 leading-normal" id="inputErrorText">Browser security prevents visiting URLs directly. Please paste the <b>Paper Title</b> or <b>DOI</b> instead.</p>
                    </div>
                </div>

                <!-- Helper Tip -->
                <div class="absolute bottom-4 right-4 text-[10px] text-[#8E8E93] bg-white px-2 py-1 rounded shadow-sm border border-ios-border opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
                    Press Ctrl+Enter to fetch
                </div>
            </div>
        </div>

        <!-- Right: Output Area -->
        <div class="w-1/2 flex flex-col bg-white">
            
            <!-- Toolbar -->
            <div class="p-4 border-b border-ios-border flex flex-col gap-4 bg-white z-10 shadow-sm">
                <div class="flex justify-between items-center">
                    <h2 class="text-sm font-semibold text-[#8E8E93] uppercase tracking-wide flex items-center gap-2">
                        <i class="ph ph-text-aa"></i> Output Style
                    </h2>
                    <div class="flex gap-2">
                         <button onclick="copyAll()" id="copyBtn" class="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-[#F2F2F7] hover:bg-[#E5E5EA] text-[#1D1D1F] text-xs font-medium transition-all active:scale-95">
                            <i class="ph ph-copy"></i> Copy Result
                        </button>
                    </div>
                </div>
                
                <!-- Style Tabs -->
                <div class="flex gap-2 overflow-x-auto pb-2 px-1 no-scrollbar items-center">
                    <button class="style-btn active px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold" onclick="setStyle('acs')">ACS</button>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('rsc')">RSC</button>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('wiley')">Wiley</button>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('springer')">Springer</button>
                    <div class="w-px h-4 bg-gray-300 mx-1 flex-shrink-0"></div>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('nature')">Nature</button>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('science')">Science</button>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('aip')">AIP</button>
                    <button class="style-btn px-3 py-1.5 rounded-full border border-ios-border text-xs font-bold bg-white text-[#8E8E93] hover:bg-gray-50" onclick="setStyle('ieee')">IEEE</button>
                </div>
            </div>

            <!-- Preview List -->
            <div class="flex-1 overflow-y-auto p-6 bg-[#F5F5F7]">
                <div id="loadingIndicator" class="hidden flex-col items-center justify-center py-10">
                    <div class="spinner border-t-blue-500 border-gray-200"></div>
                    <p class="text-xs text-[#8E8E93] mt-3" id="loadingText">Fetching metadata...</p>
                </div>

                <div id="outputList" class="space-y-4">
                    <!-- Dynamic Citations will appear here -->
                    
                    <!-- Empty State -->
                    <div id="emptyState" class="flex flex-col items-center justify-center h-full text-center opacity-60 mt-10">
                        <i class="ph ph-article text-4xl text-[#D1D1D6] mb-3"></i>
                        <p class="text-sm text-[#8E8E93] max-w-xs">Paste BibTeX, DOI, or <br><b>Paper Title</b> on the left.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-[#1D1D1F] text-white px-5 py-2.5 rounded-full text-sm font-medium shadow-lg opacity-0 transition-opacity pointer-events-none flex items-center gap-2 z-50">
        <i class="ph ph-check-circle text-green-400"></i>
        <span>Copied to clipboard</span>
    </div>

    <script>
        // --- State ---
        let currentStyle = 'acs';
        let parsedData = [];

        // --- Elements ---
        const bibInput = document.getElementById('bibInput');
        const outputList = document.getElementById('outputList');
        const emptyState = document.getElementById('emptyState');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const loadingText = document.getElementById('loadingText');
        const toast = document.getElementById('toast');
        const styleBtns = document.querySelectorAll('.style-btn');
        const fetchBtn = document.getElementById('fetchBtn');
        const inputError = document.getElementById('inputError');
        const inputErrorText = document.getElementById('inputErrorText');

        // --- Abbreviation Databases ---
        const JOURNAL_ABBR_DICT = {
            "Nature Materials": "Nat. Mater.",
            "Nature Nanotechnology": "Nat. Nanotechnol.",
            "Nature Chemistry": "Nat. Chem.",
            "Nature Communications": "Nat. Commun.",
            "Nature Physics": "Nat. Phys.",
            "Nature Biotechnology": "Nat. Biotechnol.",
            "Nature Biomedical Engineering": "Nat. Biomed. Eng.",
            "Nature Reviews Materials": "Nat. Rev. Mater.",
            "Science": "Science",
            "Nature": "Nature",
            "Journal of the American Chemical Society": "J. Am. Chem. Soc.",
            "Nano Letters": "Nano Lett.",
            "ACS Nano": "ACS Nano",
            "Advanced Materials": "Adv. Mater.",
            "Advanced Functional Materials": "Adv. Funct. Mater.",
            "Angewandte Chemie International Edition": "Angew. Chem. Int. Ed.",
            "Chemical Reviews": "Chem. Rev.",
            "Chemical Society Reviews": "Chem. Soc. Rev.",
            "Physical Review Letters": "Phys. Rev. Lett.",
            "Proceedings of the National Academy of Sciences": "Proc. Natl. Acad. Sci. U.S.A.",
            "Journal of Physical Chemistry C": "J. Phys. Chem. C",
            "Energy & Environmental Science": "Energy Environ. Sci.",
            "Environmental Science & Technology": "Environ. Sci. Technol.",
            "Advanced Energy Materials": "Adv. Energy Mater.",
            "Accounts of Chemical Research": "Acc. Chem. Res.",
            "Coordination Chemistry Reviews": "Coord. Chem. Rev.",
            "Journal of Materials Chemistry A": "J. Mater. Chem. A",
            "Chemistry of Materials": "Chem. Mater.",
            "IEEE Transactions on Pattern Analysis and Machine Intelligence": "IEEE Trans. Pattern Anal. Mach. Intell.",
            "IEEE Transactions on Image Processing": "IEEE Trans. Image Process.",
            "Pattern Recognition": "Pattern Recognit.",
            "Computer Vision and Image Understanding": "Comput. Vis. Image Underst.",
            "Applied Physics Letters": "Appl. Phys. Lett.",
            "Journal of Applied Physics": "J. Appl. Phys.",
            "Nano Research": "Nano Res.",
            "Chemical Communications": "Chem. Commun.",
        };

        const WORD_ABBR_MAP = {
            "Journal": "J.", "American": "Am.", "Chemical": "Chem.", "Society": "Soc.",
            "Review": "Rev.", "Reviews": "Rev.", "Letters": "Lett.", "Advanced": "Adv.",
            "Materials": "Mater.", "Nature": "Nat.", "Science": "Sci.", "International": "Int.",
            "Engineering": "Eng.", "Technology": "Technol.", "Transactions": "Trans.",
            "Proceedings": "Proc.", "Applied": "Appl.", "Physics": "Phys.", "Physical": "Phys.",
            "Chemistry": "Chem.", "Communications": "Commun.", "Research": "Res.",
            "Environmental": "Environ.", "Energy": "Energy", "Systems": "Syst.",
            "Computer": "Comput.", "Information": "Inf.", "European": "Eur.",
            "Academy": "Acad.", "National": "Natl.", "Sciences": "Sci.",
            "Biotechnology": "Biotechnol.", "Nanotechnology": "Nanotechnol.",
            "Biology": "Biol.", "Biological": "Biol.", "Molecular": "Mol.",
            "Cell": "Cell", "Genetics": "Genet.", "Medicine": "Med.", "Medical": "Med.",
            "Clinical": "Clin.", "Experimental": "Exp.", "Theoretical": "Theor.",
            "Bulletin": "Bull.", "Abstracts": "Abstr.",
            "Conference": "Conf.", "Symposium": "Symp.", "Annual": "Annu.",
            "Association": "Assoc.", "Institute": "Inst.", "Mathematics": "Math.",
            "Mathematical": "Math.", "Applications": "Appl.",
            "Analysis": "Anal.", "Processing": "Process.", "Intelligence": "Intell.",
            "Machine": "Mach.", "Vision": "Vis.", "Understanding": "Underst.",
            "Pattern": "Pattern", "Recognition": "Recognit.", "Computation": "Comput.",
            "Computing": "Comput.", "Software": "Softw.", "Biomedical": "Biomed.",
        };

        const SKIP_WORDS = new Set(["of", "the", "and", "in", "on", "for", "&"]);

        // --- Sample Data ---
        const SAMPLE_INPUT = `https://doi.org/10.33961/jecst.2024.00318`;

        // --- Core Logic: Regex ---
        const DOI_REGEX = /\b(10\.\d{4,9}\/[-._;()/:a-zA-Z0-9]+)\b/g;

        // --- Core Logic: Journal Abbreviation ---
        function abbreviateJournalTitle(title) {
            if (!title) return "";
            const cleanTitle = title.trim();
            if (JOURNAL_ABBR_DICT[cleanTitle]) return JOURNAL_ABBR_DICT[cleanTitle];
            
            const words = cleanTitle.split(/\s+/);
            const abbrWords = words.map(w => {
                const cleanW = w.replace(/[:,\.]/g, '');
                if (WORD_ABBR_MAP[cleanW]) return WORD_ABBR_MAP[cleanW];
                if (SKIP_WORDS.has(cleanW.toLowerCase())) return null;
                return w;
            }).filter(w => w !== null);
            
            return abbrWords.join(' ');
        }

        // --- Core Logic: Fetching Metadata (DOI) ---
        async function fetchCrossref(doi) {
            try {
                const response = await fetch(`https://api.crossref.org/works/${encodeURIComponent(doi)}`);
                if (!response.ok) return null;
                const data = await response.json();
                return data.message;
            } catch (error) {
                console.error("DOI Fetch error:", error);
                return null;
            }
        }

        // --- Core Logic: Search Metadata (Title) ---
        async function searchCrossref(query) {
            try {
                const url = `https://api.crossref.org/works?query.bibliographic=${encodeURIComponent(query)}&rows=1`;
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                const items = data.message.items;
                return items.length > 0 ? items[0] : null;
            } catch (error) {
                console.error("Search error:", error);
                return null;
            }
        }

        function mapCrossrefToInternal(data) {
            const authors = (data.author || []).map(a => ({
                first: a.given || '',
                last: a.family || ''
            }));

            let jName = data['container-title'] ? data['container-title'][0] : (data.publisher || '');
            if (data['short-container-title'] && data['short-container-title'].length > 0) {
                jName = data['short-container-title'][0];
            }

            return {
                type: data.type || 'article',
                title: data.title ? data.title[0] : 'Untitled',
                journal: jName,
                year: data.issued?.['date-parts']?.[0]?.[0] || '',
                volume: data.volume || '',
                number: data.issue || '',
                pages: data.page || '',
                publisher: data.publisher || '',
                doi: data.DOI || '',
                authors: authors,
                isSearch: false
            };
        }

        // --- Core Logic: BibTeX Parser ---
        function parseBibTeX(input) {
            const entries = input.split('@').filter(e => e.trim().length > 0 && !e.trim().startsWith('10.')); 
            return entries.map(entry => {
                if (!entry.includes('{')) return null;

                const result = {};
                const typeMatch = entry.match(/^([a-zA-Z]+)\s*\{/);
                if (typeMatch) result.type = typeMatch[1].toLowerCase();

                const extract = (key) => {
                    const regex = new RegExp(`${key}\\s*=\\s*[{"'](.+?)[}"'][,\\n]`, 'i');
                    const match = entry.match(regex);
                    return match ? match[1].replace(/[{}]/g, '') : '';
                };

                result.title = extract('title');
                result.journal = extract('journal');
                result.year = extract('year');
                result.volume = extract('volume');
                result.number = extract('number') || extract('issue');
                result.pages = extract('pages').replace('--', '-');
                result.publisher = extract('publisher');
                result.doi = extract('doi');

                const rawAuthors = extract('author');
                if (rawAuthors) {
                    result.authors = rawAuthors.split(' and ').map(a => {
                        if (a.includes(',')) {
                            const parts = a.split(',');
                            return { last: parts[0].trim(), first: parts[1]?.trim() || '' };
                        } else {
                            const words = a.trim().split(' ');
                            const last = words.pop();
                            const first = words.join(' ');
                            return { last, first };
                        }
                    });
                } else {
                    result.authors = [];
                }
                return result;
            }).filter(item => item !== null && item.title);
        }

        // --- Core Logic: Main Processor ---
        async function processInput() {
            const rawInput = bibInput.value;
            inputError.classList.add('hidden'); 
            
            if (!rawInput.trim()) {
                parsedData = [];
                render();
                return;
            }

            // UI Loading
            loadingText.textContent = "Processing...";
            loadingIndicator.classList.remove('hidden');
            loadingIndicator.classList.add('flex');
            outputList.classList.add('opacity-50');
            emptyState.style.display = 'none';

            // 1. Check for DOIs in text
            const doisFound = [...rawInput.matchAll(DOI_REGEX)].map(m => m[1]);
            
            // 2. Parse BibTeX
            let results = parseBibTeX(rawInput);
            const existingDOIs = new Set(results.map(r => r.doi));
            const doisToFetch = [...new Set(doisFound)].filter(d => !existingDOIs.has(d));

            // 3. Logic Branching
            // Case A: No BibTeX and No DOIs found
            if (results.length === 0 && doisToFetch.length === 0) {
                // Heuristic: Is it a URL?
                const isUrl = rawInput.trim().match(/^https?:\/\//);
                
                if (isUrl) {
                    // Show Error: URL not supported without DOI
                    loadingIndicator.classList.remove('flex');
                    loadingIndicator.classList.add('hidden');
                    outputList.classList.remove('opacity-50');
                    
                    inputErrorText.innerHTML = `This looks like a direct URL (like ScienceDirect). <br>Browser security prevents visiting it. Please paste the <b>Paper Title</b> instead!`;
                    inputError.classList.remove('hidden');
                    inputError.classList.add('shake');
                    setTimeout(() => inputError.classList.remove('shake'), 500);
                    
                    if(parsedData.length === 0) emptyState.style.display = 'flex';
                    return;
                } else {
                    // Treat as TITLE SEARCH
                    loadingText.textContent = "Searching Title...";
                    const searchResult = await searchCrossref(rawInput);
                    
                    if (searchResult) {
                        const mapped = mapCrossrefToInternal(searchResult);
                        mapped.isSearch = true; // Flag to show it was a search result
                        results.push(mapped);
                    } else {
                        // Failed search
                        loadingIndicator.classList.remove('flex');
                        loadingIndicator.classList.add('hidden');
                        outputList.classList.remove('opacity-50');
                        inputErrorText.textContent = "Could not find any paper matching this text.";
                        inputError.classList.remove('hidden');
                        if(parsedData.length === 0) emptyState.style.display = 'flex';
                        return;
                    }
                }
            }

            // Case B: Fetch DOIs if found
            if (doisToFetch.length > 0) {
                loadingText.textContent = `Fetching ${doisToFetch.length} DOIs...`;
                const fetchPromises = doisToFetch.map(doi => fetchCrossref(doi));
                const fetchedData = await Promise.all(fetchPromises);
                
                fetchedData.forEach(data => {
                    if (data) results.push(mapCrossrefToInternal(data));
                });
            }

            parsedData = results;

            // Finish
            loadingIndicator.classList.remove('flex');
            loadingIndicator.classList.add('hidden');
            outputList.classList.remove('opacity-50');
            render();
        }

        // --- Core Logic: Formatters ---
        function formatName(author, style) {
            if (!author || !author.last) return "";
            const first = author.first || "";
            
            // Format first name initials
            const initials = first.split(' ').map(n => n[0]).join(''); // "JB"
            const initialsDot = first.split(' ').map(n => n[0] + '.').join(''); // "J.B."
            const initialsSpaced = first.split(' ').map(n => n[0] + '.').join(' '); // "J. B."
            
            // Styles
            if (style === 'acs') return `${author.last}, ${initialsSpaced}`; // Doe, J. B.
            if (style === 'rsc') return `${initialsSpaced} ${author.last}`; // J. B. Doe
            if (style === 'wiley') return `${initialsDot} ${author.last}`; // J.B. Doe
            if (style === 'springer') return `${author.last} ${initials}`; // Doe JB
            if (style === 'nature') return `${author.last}, ${initialsDot}`; // Doe, J.B.
            if (style === 'science') return `${initialsDot} ${author.last}`; // J.B. Doe
            if (style === 'aip') return `${initialsDot} ${author.last}`; // J.B. Doe
            if (style === 'ieee') return `${initialsSpaced} ${author.last}`; // J. B. Doe
            if (style === 'apa') return `${author.last}, ${initialsSpaced}`; // Doe, J. B.
            
            return author.last;
        }

        function formatAuthors(authors, style) {
            if (!authors || authors.length === 0) return "Unknown Author";
            const formatted = authors.map(a => formatName(a, style));

            if (style === 'acs') {
                return formatted.join('; ');
            } 
            else if (style === 'rsc') {
                // A. Name, B. Name and C. Name
                if (formatted.length === 1) return formatted[0];
                return formatted.slice(0, -1).join(', ') + ' and ' + formatted[formatted.length - 1];
            }
            else if (style === 'wiley') {
                // A. Name, B. Name
                return formatted.join(', ');
            }
            else if (style === 'springer') {
                // Name A, Name B
                return formatted.join(', ');
            }
            else if (style === 'nature') {
                if (formatted.length > 5) return `${formatted[0]} <em>et al.</em>`;
                if (formatted.length === 1) return formatted[0];
                return formatted.slice(0, -1).join(', ') + ' & ' + formatted[formatted.length - 1];
            } 
            else if (style === 'science') {
                 // Science usually comma separated: A. Author, B. Author
                return formatted.join(', ');
            } 
            else if (style === 'aip') {
                 // AIP: A. Author and B. Author
                if (formatted.length === 1) return formatted[0];
                return formatted.slice(0, -1).join(', ') + ' and ' + formatted[formatted.length - 1];
            }
            else if (style === 'ieee') {
                // IEEE: A. Author and B. Author
                if (formatted.length > 3) return `${formatted[0]} <em>et al.</em>`;
                if (formatted.length === 1) return formatted[0];
                return formatted.slice(0, -1).join(', ') + ' and ' + formatted[formatted.length - 1];
            } 
            else if (style === 'apa') {
                if (formatted.length > 20) return `${formatted.slice(0,19).join(', ')}, ... ${formatted[formatted.length-1]}`;
                if (formatted.length === 1) return formatted[0];
                return formatted.slice(0, -1).join(', ') + ', & ' + formatted[formatted.length - 1];
            }
            return formatted.join(', ');
        }

        function renderCitation(data, style) {
            const authors = formatAuthors(data.authors, style);
            const journalAbbr = abbreviateJournalTitle(data.journal);
            
            // ACS: Author; Author. Title (Optional). J. Abbr. Year, Vol, Page.
            if (style === 'acs') {
                return `${authors} ${data.title}. <em>${journalAbbr}</em> <strong>${data.year}</strong>, <em>${data.volume}</em>, ${data.pages}.`;
            } 
            // RSC: Author, J. Abbr., Year, Vol, Page. (No Title)
            else if (style === 'rsc') {
                return `${authors}, <em>${journalAbbr}</em>, ${data.year}, <strong>${data.volume}</strong>, ${data.pages}.`;
            }
            // Wiley (Angew/Adv.Mater): Author, J. Abbr. Year, Vol, Page. (No Title, Year Bold)
            else if (style === 'wiley') {
                return `${authors}, <em>${journalAbbr}</em> <strong>${data.year}</strong>, <em>${data.volume}</em>, ${data.pages}.`;
            }
            // Springer: Author (Year) Title. J Abbr Vol:Page.
            else if (style === 'springer') {
                return `${authors} (${data.year}) ${data.title}. ${journalAbbr} ${data.volume}:${data.pages}.`;
            }
            // Nature: Author. Title. J. Abbr. Vol, Page (Year).
            else if (style === 'nature') {
                return `${authors} ${data.title}. <em>${journalAbbr}</em> <strong>${data.volume}</strong>, ${data.pages} (${data.year}).`;
            }
            // Science: Author, Title. J. Abbr. Vol, Page (Year).
            else if (style === 'science') {
                return `${authors} ${data.title}. <em>${journalAbbr}</em> <strong>${data.volume}</strong>, ${data.pages} (${data.year}).`;
            }
            // AIP: Author, "Title," J. Abbr. Vol, Page (Year).
            else if (style === 'aip') {
                return `${authors}, "${data.title}," <em>${journalAbbr}</em> <strong>${data.volume}</strong>, ${data.pages} (${data.year}).`;
            }
            // IEEE
            else if (style === 'ieee') {
                return `${authors}, "${data.title}," <em>${journalAbbr}</em>, vol. ${data.volume}, ${data.number ? 'no. '+data.number+', ' : ''}pp. ${data.pages}, ${data.year}.`;
            }
            // APA
            else if (style === 'apa') {
                return `${authors} (${data.year}). ${data.title}. <em>${journalAbbr}</em>, <em>${data.volume}</em>${data.number ? '('+data.number+')' : ''}, ${data.pages}.`;
            }
            return "";
        }

        // --- UI Logic ---
        function render() {
            outputList.innerHTML = '';
            
            if (parsedData.length === 0) {
                emptyState.style.display = 'flex';
                return;
            } else {
                emptyState.style.display = 'none';
            }

            parsedData.forEach((item, index) => {
                const html = renderCitation(item, currentStyle);
                
                const card = document.createElement('div');
                card.className = "ios-card p-4 relative group hover:shadow-md transition-shadow";
                
                const num = index + 1;
                let numBadge = "";
                
                // Numbering Styles
                if (['ieee', 'springer', 'nature', 'aip', 'rsc', 'wiley'].includes(currentStyle)) {
                    // Bracket style for IEEE/AIP, Dot for others? 
                    // Let's stick to standard numbering for list view clarity
                    const format = (currentStyle === 'ieee' || currentStyle === 'aip') ? `[${num}]` : `${num}.`;
                    const color = (currentStyle === 'ieee') ? 'text-ios-blue' : 'text-[#8E8E93]';
                    numBadge = `<span class="text-xs font-mono ${color} mr-2 w-4 inline-block text-right">${format}</span>`;
                }

                // Search Result Badge
                const searchBadge = item.isSearch ? `<span class="block mb-2 text-[10px] font-bold text-orange-500 uppercase tracking-wide">Search Result</span>` : '';

                card.innerHTML = `
                    ${searchBadge}
                    <div class="citation-preview text-sm leading-relaxed pr-8 text-[#1D1D1F]">
                        ${numBadge}${html}
                    </div>
                    <button onclick="copySingle(this)" class="absolute top-3 right-3 p-1.5 rounded-md text-[#8E8E93] hover:text-ios-blue hover:bg-blue-50 opacity-0 group-hover:opacity-100 transition-all" title="Copy">
                        <i class="ph ph-copy text-lg"></i>
                    </button>
                `;
                outputList.appendChild(card);
            });
        }

        function setStyle(style) {
            currentStyle = style;
            styleBtns.forEach(btn => {
                if (btn.getAttribute('onclick').includes(style)) {
                    btn.classList.add('active');
                    btn.classList.remove('bg-white', 'text-[#8E8E93]', 'hover:bg-gray-50');
                } else {
                    btn.classList.remove('active');
                    btn.classList.add('bg-white', 'text-[#8E8E93]', 'hover:bg-gray-50');
                }
            });
            render();
        }

        function clearInput() {
            bibInput.value = '';
            parsedData = [];
            inputError.classList.add('hidden');
            render();
            bibInput.focus();
        }

        function showToast(msg) {
            toast.querySelector('span').textContent = msg;
            toast.style.opacity = '1';
            toast.style.transform = 'translate(-50%, -20px)';
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translate(-50%, 0)';
            }, 2000);
        }

        function copyAll() {
            if (parsedData.length === 0) return;
            const tempDiv = document.createElement("div");
            let plainText = "";
            parsedData.forEach((item, index) => {
                const html = renderCitation(item, currentStyle);
                tempDiv.innerHTML = html;
                const text = tempDiv.textContent || tempDiv.innerText;
                
                // Add numbering for numeric styles in clipboard copy
                if (['ieee', 'aip'].includes(currentStyle)) plainText += `[${index+1}] ${text}\n`;
                else if (['springer', 'nature', 'rsc', 'wiley'].includes(currentStyle)) plainText += `${index+1}. ${text}\n`;
                else plainText += `${text}\n`;
            });
            navigator.clipboard.writeText(plainText).then(() => showToast("All citations copied"));
        }

        function copySingle(btn) {
            const preview = btn.parentElement.querySelector('.citation-preview');
            const text = preview.innerText; 
            navigator.clipboard.writeText(text).then(() => showToast("Copied"));
        }

        bibInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                processInput();
            }
        });

        window.onload = () => {
            bibInput.value = SAMPLE_INPUT;
            processInput(); 
        };

    </script>
</body>
</html>